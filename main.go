package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
	"github.com/robfig/cron/v3"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"time"
)

// Tenant –æ–ø–∏—Å—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞
type Tenant struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	Apartment   string `json:"apartment"`
	PaymentDate string `json:"paymentDate"` // —Ñ–æ—Ä–º–∞—Ç "2006-01-02"
}

var db *sql.DB

func initPostgres() error {
	dsn := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		os.Getenv("POSTGRES_HOST"),
		os.Getenv("POSTGRES_PORT"),
		os.Getenv("POSTGRES_USER"),
		os.Getenv("POSTGRES_PASSWORD"),
		os.Getenv("POSTGRES_DB"),
	)

	var err error
	db, err = sql.Open("postgres", dsn)
	if err != nil {
		return err
	}
	return db.Ping()
}

func migrate() error {
	query := `
	CREATE TABLE IF NOT EXISTS tenants (
		id SERIAL PRIMARY KEY,
		name TEXT NOT NULL,
		apartment TEXT NOT NULL,
		payment_date DATE NOT NULL
	);`
	_, err := db.Exec(query)
	return err
}

// sendTelegramMessage –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç Telegram-—Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Bot API
func sendTelegramMessage(message string) error {
	botToken := os.Getenv("TELEGRAM_BOT_TOKEN")
	chatID := os.Getenv("TELEGRAM_CHAT_ID")

	url := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage", botToken)

	body, _ := json.Marshal(map[string]string{
		"chat_id": chatID,
		"text":    message,
	})

	resp, err := http.Post(url, "application/json", bytes.NewBuffer(body))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		resBody, _ := ioutil.ReadAll(resp.Body)
		return fmt.Errorf("telegram error: %s", resBody)
	}

	return nil
}

// checkPaymentDates –ø—Ä–æ—Ö–æ–¥–∏—Ç –ø–æ –≤—Å–µ–º –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
func checkPaymentDates() {
	now := time.Now().Truncate(24 * time.Hour)
	tomorrow := now.Add(24 * time.Hour)
	threeDaysLater := now.Add(72 * time.Hour)

	fmt.Println("–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞—Ç –æ–ø–ª–∞—Ç—ã –Ω–∞", now.Format("2006-01-02"))

	rows, err := db.Query(`SELECT name, apartment, payment_date FROM tenants`)
	if err != nil {
		log.Printf("–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ –±–∞–∑–µ: %v\n", err)
		return
	}
	defer rows.Close()

	for rows.Next() {
		var t Tenant
		var pd time.Time

		if err := rows.Scan(&t.Name, &t.Apartment, &pd); err != nil {
			log.Println("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Å—Ç—Ä–æ–∫–∏:", err)
			continue
		}
		t.PaymentDate = pd.Format("2006-01-02")

		if pd.Equal(threeDaysLater) {
			message := fmt.Sprintf("–ü—Ä–∏–≤–µ—Ç, %s! –ß–µ—Ä–µ–∑ 3 –¥–Ω—è (%s) –Ω—É–∂–Ω–æ –æ–ø–ª–∞—Ç–∏—Ç—å –∞—Ä–µ–Ω–¥—É –∫–≤–∞—Ä—Ç–∏—Ä—ã %s.",
				t.Name, pd.Format("02 January 2006"), t.Apartment)
			if err := sendTelegramMessage(message); err != nil {
				log.Printf("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ (–∑–∞ 3 –¥–Ω—è) –¥–ª—è %s: %v\n", t.Name, err)
			}
		} else if pd.Equal(tomorrow) {
			message := fmt.Sprintf("–ü—Ä–∏–≤–µ—Ç, %s! –ó–∞–≤—Ç—Ä–∞ (%s) –Ω—É–∂–Ω–æ –æ–ø–ª–∞—Ç–∏—Ç—å –∞—Ä–µ–Ω–¥—É –∫–≤–∞—Ä—Ç–∏—Ä—ã %s.",
				t.Name, pd.Format("02 January 2006"), t.Apartment)
			if err := sendTelegramMessage(message); err != nil {
				log.Printf("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ (–∑–∞ 1 –¥–µ–Ω—å) –¥–ª—è %s: %v\n", t.Name, err)
			}
		}
	}
}

// startBot –∑–∞–ø—É—Å–∫–∞–µ—Ç Telegram-–±–æ—Ç–∞ (–≤—Ä–µ–º–µ–Ω–Ω–æ –±–µ–∑ –∫–æ–º–∞–Ω–¥)
func startBot() {
	bot, err := tgbotapi.NewBotAPI(os.Getenv("TELEGRAM_BOT_TOKEN"))
	if err != nil {
		log.Fatal(err)
	}
	bot.Debug = true
	log.Printf("–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∫–∞–∫ %s", bot.Self.UserName)
}

func main() {
	// .env
	if err := godotenv.Load(); err != nil {
		log.Println("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ .env —Ñ–∞–π–ª–∞:", err)
	}

	if err := initPostgres(); err != nil {
		log.Fatalf("–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ PostgreSQL: %v", err)
	}
	if err := migrate(); err != nil {
		log.Fatalf("–û—à–∏–±–∫–∞ –º–∏–≥—Ä–∞—Ü–∏–∏: %v", err)
	}

	// Cron
	c := cron.New()
	_, err := c.AddFunc("0 9 * * *", func() {
		fmt.Println("–ó–∞–ø—É—Å–∫ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–æ–≤ –≤ 09:00")
		checkPaymentDates()
	})
	if err != nil {
		fmt.Println("–û—à–∏–±–∫–∞ cron:", err)
	}
	c.Start()

	// Telegram bot
	go startBot()

	// Gin
	router := gin.Default()

	router.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"http://localhost:5185", "https://eskertu-bot.vercel.app"},
		AllowMethods:     []string{"POST", "GET", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type"},
		AllowCredentials: true,
	}))

	// POST /api/tenants ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞
	router.POST("/api/tenants", func(c *gin.Context) {
		var t Tenant
		if err := c.ShouldBindJSON(&t); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ"})
			return
		}

		paymentDate, err := time.Parse("2006-01-02", t.PaymentDate)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã"})
			return
		}

		query := `INSERT INTO tenants (name, apartment, payment_date) VALUES ($1, $2, $3)`
		_, err = db.Exec(query, t.Name, t.Apartment, paymentDate)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ë–î"})
			return
		}

		message := fmt.Sprintf("üì¢ –ù–æ–≤—ã–π –∫–≤–∞—Ä—Ç–∏—Ä–∞–Ω—Ç:\nüë§ –ò–º—è: %s\nüè† –ö–≤–∞—Ä—Ç–∏—Ä–∞: %s\nüí∞ –î–∞—Ç–∞ –æ–ø–ª–∞—Ç—ã: %s",
			t.Name, t.Apartment, t.PaymentDate)
		if err := sendTelegramMessage(message); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "–û—à–∏–±–∫–∞ Telegram", "details": err.Error()})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"message": "–ê—Ä–µ–Ω–¥–∞—Ç–æ—Ä –¥–æ–±–∞–≤–ª–µ–Ω –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ",
			"tenant":  t,
		})
	})

	// GET /ping
	router.GET("/ping", func(c *gin.Context) {
		c.String(http.StatusOK, "pong")
	})

	// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
	router.Run(":8080")
}
